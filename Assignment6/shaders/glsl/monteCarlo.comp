#version 460
#extension GL_EXT_debug_printf : enable


layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;


layout(set = 0, binding = 0, rgba32f) uniform image2D ImageBuffer;


layout(set = 0, binding = 1) uniform CameraData{
    vec3 cameraWorldPos;
    mat4 viewMatrix;
    mat4 projectionMatrix;
};

layout (set = 0, binding = 2) uniform ScreenData{
    uint width;
    uint height;
};

layout(set = 0, binding = 3, rgba32f) uniform image2D randomValues;

layout(set = 1, binding = 0) buffer Vertices {
    vec3 vertices[];
};

layout(set = 1, binding = 1) buffer Indices {
    uvec3 indices[];
};

vec3 sunColor = vec3(1.64, 1.27, 0.99);
vec3 sunDirection = vec3(1,0.75,1);
vec3 skyColorLow = vec3(0.36, 0.45, 0.57);
vec3 skyColorHigh = vec3(0.14, 0.21, 0.49);
vec3 voidColor = vec3(0.025, 0.05, 0.075);

vec3 backgroundColor(vec3 rd){
    if(rd.y < 0.0)
        return voidColor;
    const float skyGradient = 1./4.;
    vec3 skyColor = mix(skyColorLow, skyColorHigh, pow(rd.y, skyGradient));
    const float sunGradient = 2400.;
    float sunAmount = pow(max(dot(rd,normalize(sunDirection)), 0.),sunGradient);
    return mix(skyColor, sunColor, sunAmount);
}


vec3 lightAtPoint(vec3 point, vec3 N){
    vec3 L = normalize(sunDirection);
    float NdL = max(dot(N,L),0.0);
    float NdSky = clamp(0.5*N.y+0.5, 0.0, 1.0 );
    return sunColor*NdL + skyColorHigh * NdSky;
}

const int maxBounces = 2;
vec3 baseColor = vec3(1.0, 0.0, 0.0);

struct Ray {
    vec3 origin;
    vec3 direction;
};

// Function to check intersection with a triangle
vec3 triIntersect(in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2) {
    vec3 v1v0 = v1 - v0;
    vec3 v2v0 = v2 - v0;
    vec3 rov0 = ro - v0;
    vec3 n = cross(v1v0, v2v0);
    vec3 q = cross(rov0, rd);
    float d = 1.0 / dot(rd, n);
    float u = d * dot(-q, v2v0);
    float v = d * dot(q, v1v0);
    float t = d * dot(-n, rov0);
    if (u < 0.0 || v < 0.0 || (u + v) > 1.0)
        t = -1.0;
    return vec3(t, u, v);
}

// (In the end I used texture of random values)

// Function to generate random values in [0,1]
// float rand (vec2 st) {
//     return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);
// }

// vec3 randomVec3(vec2 seed) {
//     return vec3(fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453),
//                 fract(sin(dot(seed, vec2(4.898, 7.23))) * 78432.5453),
//                 fract(sin(dot(seed, vec2(1.32, 9.235))) * 87864.5453));
// }

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
};

vec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )
{
    vec3 oc = ro - ce;
    float b = dot( oc, rd );
    vec3 qc = oc - b*rd;
    float h = ra*ra - dot( qc, qc );
    if( h<0.0 ) return vec2(-1.0); // no intersection
    h = sqrt( h );
    return vec2( -b-h, -b+h );
}


void main() {

// ------------------------------ how it should work with a tri mesh -------------------------------------------
    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);

    vec2 normalizedStorePos = vec2(storePos.x / float(width), storePos.y / float(height));
    vec2 ndc = 2. * normalizedStorePos -1.;  //Map to screen space back to NDC
    vec3 pixelViewSpace = (inverse(projectionMatrix) * vec4(ndc, 1.,1.)).xyz; //Project back to ViewSpace using inverse projection matrix

    // Primary ray generation
    Ray primaryRay;
    primaryRay.origin = cameraWorldPos; //ray origin = camera world position
    primaryRay.direction = normalize(mat3(inverse(viewMatrix)) * pixelViewSpace); //Project back to WorldSpace using inverse view matrix

    vec3 color = backgroundColor(primaryRay.direction);

// Monte Carlo ray tracing with random bouncing
    for (int bounce = 0; bounce < maxBounces; ++bounce) {
        // Find the closest intersection with the mesh
        float closestT = 1e30;
        int closestIndex = -1;

        for (int i = 0; i < indices.length(); i++) {
            vec3 v0 = vertices[indices[i].x];
            vec3 v1 = vertices[indices[i].y];
            vec3 v2 = vertices[indices[i].z];

            vec3 intersection = triIntersect(primaryRay.origin, primaryRay.direction, v0, v1, v2);
            float t = intersection.x;

            if (t > 0.0 && t < closestT) {
                closestT = t;
                closestIndex = i;
            }
        }
        // If an intersection is found, update ray and accumulate color
        if (closestIndex != -1) {
            vec3 hitPoint = primaryRay.origin + primaryRay.direction * closestT;
            vec3 v0 = vertices[indices[closestIndex].x];
            vec3 v1 = vertices[indices[closestIndex].y];
            vec3 v2 = vertices[indices[closestIndex].z];
            vec3 normal = normalize(cross(v1 - v0, v2 - v0)); // Compute the normal of the triangle
            vec3 light = lightAtPoint(hitPoint, normal);

            // Example shading: Lambertian reflection
            vec3 randomVec = imageLoad(randomValues, storePos).rgb;
            vec3 newDirection = normalize(normal + randomVec);
            primaryRay.origin = hitPoint + 0.001 * newDirection;
            primaryRay.direction = newDirection;

            // Accumulate color (for simplicity, just use white)
            color = light * baseColor;
        } else {
            break; // No intersection found, terminate the loop
        }
    }

    // Store the accumulated color in the image buffer
    //imageStore(ImageBuffer, storePos, vec4(color, 1.0));
    imageStore(ImageBuffer, storePos, vec4(color / float(maxBounces), 1.0));
//----------------------------------------------------------------------
    

    //----------------random colors (this works) ---------------------------- 
    //  ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
    //  imageStore(ImageBuffer, storePos, vec4( randomVec3(storePos), 1.0));


    // ---------------------- sphere (it works!) -----------------------------------------------------
    // ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);

    // vec2 normalizedStorePos = vec2(storePos.x / float(width), storePos.y / float(height));
    // vec2 ndc = 2. * normalizedStorePos -1.;  //Map to screen space back to NDC
    // vec3 pixelViewSpace = (inverse(projectionMatrix) * vec4(ndc, 1.,1.)).xyz; //Project back to ViewSpace using inverse projection matrix

    // // Primary ray generation
    // Ray primaryRay;
    // primaryRay.origin = cameraWorldPos; //ray origin = camera world position
    // primaryRay.direction = normalize(mat3(inverse(viewMatrix)) * pixelViewSpace); //Project back to WorldSpace using inverse view matrix

    // vec3 color;

    // Sphere s;
    // s.center = vec3(0.0, 2, 0.0);
    // s.radius = 1;
    // s.color = vec3(1.0, 1.0, 0.0);

    // vec2 intersections = sphIntersect(primaryRay.origin, primaryRay.direction, s.center, s.radius);
    // float t = intersections.y;
    // //debugPrintfEXT("NDC is %f", t);

    // if (t != -1.0){
    //     color = s.color;
    // }
    // else {
    //     color = backgroundColor(primaryRay.direction);
    // }
    // imageStore(ImageBuffer, storePos, vec4(color, 1.0));
// ----------------------------------------------------------------------------------------------------------


// ----------------------- single triangle (WORKS!) -------------------------------------------------
    // ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);

    // vec2 normalizedStorePos = vec2(storePos.x / float(width), storePos.y / float(height));
    // vec2 ndc = 2. * normalizedStorePos -1.;  //Map to screen space back to NDC
    // vec3 pixelViewSpace = (inverse(projectionMatrix) * vec4(ndc, 1.,1.)).xyz; //Project back to ViewSpace using inverse projection matrix

    // // Primary ray generation
    // Ray primaryRay;
    // primaryRay.origin = cameraWorldPos; //ray origin = camera world position
    // primaryRay.direction = normalize(mat3(inverse(viewMatrix)) * pixelViewSpace); //Project back to WorldSpace using inverse view matrix

    // vec3 color;
    // vec3 v0 = vec3(-0.5, 1.5, 0);
    // vec3 v1 = vec3(0, 2.5, 0);
    // vec3 v2 = vec3(0.5, 1.5, 0);

    // // debugPrintfEXT("storePos is %v3f", primaryRay.origin);

    // vec3 intersection = triIntersect(primaryRay.origin, primaryRay.direction, v0, v1, v2);
    // float t = intersection.x;
    // if (t > 0.0){
    //     color = vec3(1.0, 0.0, 0.0);
    // }
    // else {
    //     color = backgroundColor(primaryRay.direction);
    // }
    // imageStore(ImageBuffer, storePos, vec4(color, 1.0));
// ----------------------------------------------------------------------------------------
}
